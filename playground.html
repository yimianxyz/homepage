<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no">
    <meta name="description" content="Boids Simulation Playground - Test and Debug">
    <meta name="keywords" content="boids, simulation, flocking, predator, prey, debugging, playground">
    <meta name="author" content="Yimian Liu">
    <title>Boids Simulation Playground</title>
    
    <!-- Shared styles -->
    <link rel="stylesheet" href="shared.css">
    <link rel="stylesheet" href="playground.css">
    
    <!-- Configuration -->
    <script src="config/constants.js"></script>
    
    <!-- Simulation Runtime -->
    <script src="simulation/runtime/simulation_runtime.js"></script>
    
    <!-- Processors -->
    <script src="simulation/processors/input_processor.js"></script>
    <script src="simulation/processors/action_processor.js"></script>
    
    <!-- State Management -->
    <script src="simulation/state_manager/state_manager.js"></script>
    
    <!-- Random State Generator -->
    <script src="simulation/random_state_generator/random_state_generator.js"></script>
    
    <!-- Policies -->
    <script src="policy/human_prior/closest_pursuit_policy.js"></script>
    <script src="policy/transformer/utils/transformer_encoder.js"></script>
    <script src="policy/transformer/utils/transformer_policy_wrapper.js"></script>
    <script src="policy/transformer/transformer_policy.js"></script>
    <script src="policy/transformer/models/2.js"></script>
    
    <!-- Rewards -->
    <script src="rewards/reward_processor.js"></script>
    
    <!-- UI Modules -->
    <script src="ui/canvas.js"></script>
    <script src="ui/rendering.js"></script>
    <script src="ui/simulation.js"></script>
    <script src="ui/utils.js"></script>
</head>
<body>
    <canvas id="playground-canvas" class="simulation-canvas"></canvas>
    
    <!-- Control Panel -->
    <div class="playground-controls">
        <h3>üéÆ Simulation Controls</h3>
        
        <!-- Simulation Controls -->
        <div class="control-group">
            <div class="collapsible active" id="sim-controls-toggle">‚ñº Simulation</div>
            <div class="collapsible-content active" id="sim-controls">
                <button id="start-btn" class="success">‚ñ∂Ô∏è Start</button>
                <button id="pause-btn">‚è∏Ô∏è Pause</button>
                <button id="reset-btn" class="danger">üîÑ Reset</button>
                <button id="step-btn">‚è≠Ô∏è Step</button>
                
                <label>Speed: <span class="value-display" id="speed-value">1.0x</span></label>
                <input type="range" id="speed-slider" min="0.1" max="3.0" step="0.1" value="1.0">
            </div>
        </div>
        
        <!-- Policy Controls -->
        <div class="control-group">
            <div class="collapsible active" id="policy-controls-toggle">‚ñº Policy</div>
            <div class="collapsible-content active" id="policy-controls">
                <label>Policy Type:</label>
                <select id="policy-select">
                    <option value="closest_pursuit">Closest Pursuit</option>
                    <option value="transformer" selected>Transformer</option>
                </select>
                <button id="load-policy-btn">üîÑ Load Policy</button>
            </div>
        </div>
        
        <!-- Boid Parameters -->
        <div class="control-group">
            <div class="collapsible" id="boid-controls-toggle">‚ñ∂ Boid Parameters</div>
            <div class="collapsible-content" id="boid-controls">
                <label>Count: <span class="value-display" id="boid-count-value">50</span></label>
                <input type="range" id="boid-count-slider" min="10" max="200" step="10" value="50">
                
                <label>Max Speed: <span class="value-display" id="boid-speed-value">3.5</span></label>
                <input type="range" id="boid-speed-slider" min="1" max="8" step="0.1" value="3.5">
                
                <label>Max Force: <span class="value-display" id="boid-force-value">0.1</span></label>
                <input type="range" id="boid-force-slider" min="0.01" max="0.5" step="0.01" value="0.1">
                
                <label>Neighbor Distance: <span class="value-display" id="neighbor-dist-value">60</span></label>
                <input type="range" id="neighbor-dist-slider" min="20" max="150" step="5" value="60">
                
                <label>Separation: <span class="value-display" id="separation-value">2.0</span></label>
                <input type="range" id="separation-slider" min="0" max="5" step="0.1" value="2.0">
                
                <label>Cohesion: <span class="value-display" id="cohesion-value">1.0</span></label>
                <input type="range" id="cohesion-slider" min="0" max="5" step="0.1" value="1.0">
                
                <label>Alignment: <span class="value-display" id="alignment-value">1.0</span></label>
                <input type="range" id="alignment-slider" min="0" max="5" step="0.1" value="1.0">
            </div>
        </div>
        
        <!-- Predator Parameters -->
        <div class="control-group">
            <div class="collapsible" id="predator-controls-toggle">‚ñ∂ Predator Parameters</div>
            <div class="collapsible-content" id="predator-controls">
                <label>Max Speed: <span class="value-display" id="predator-speed-value">2.0</span></label>
                <input type="range" id="predator-speed-slider" min="0.5" max="6" step="0.1" value="2.0">
                
                <label>Max Force: <span class="value-display" id="predator-force-value">0.2</span></label>
                <input type="range" id="predator-force-slider" min="0.01" max="1" step="0.01" value="0.2">
                
                <label>Range: <span class="value-display" id="predator-range-value">80</span></label>
                <input type="range" id="predator-range-slider" min="30" max="200" step="5" value="80">
                
                <label>Turn Factor: <span class="value-display" id="turn-factor-value">0.3</span></label>
                <input type="range" id="turn-factor-slider" min="0.1" max="2" step="0.1" value="0.3">
            </div>
        </div>
        
        <!-- Visual Options -->
        <div class="control-group">
            <div class="collapsible" id="visual-controls-toggle">‚ñ∂ Visual Options</div>
            <div class="collapsible-content" id="visual-controls">
                <label><input type="checkbox" id="show-debug"> Show Debug Info</label>
                <label><input type="checkbox" id="show-velocity"> Show Velocity</label>
                <label><input type="checkbox" id="show-range"> Show Predator Range</label>
                <label><input type="checkbox" id="show-indices"> Show Boid Indices</label>
                <label><input type="checkbox" id="show-performance"> Show Performance</label>
                <label><input type="checkbox" id="show-policy-status"> Show Policy Status</label>
                
                <label>Background:</label>
                <select id="background-select">
                    <option value="transparent">Transparent</option>
                    <option value="white">White</option>
                    <option value="black">Black</option>
                    <option value="fade">Fade Trail</option>
                </select>
            </div>
        </div>
        
        <!-- Replay Controls -->
        <div class="control-group">
            <div class="collapsible" id="replay-controls-toggle">‚ñ∂ Replay Controls</div>
            <div class="collapsible-content" id="replay-controls">
                <button id="start-replay-btn">üé¨ Start Replay</button>
                <button id="stop-replay-btn" disabled>‚èπÔ∏è Stop Replay</button>
                
                <div class="replay-navigation">
                    <button id="replay-prev-10-btn" disabled>‚è™ -10</button>
                    <button id="replay-prev-btn" disabled>‚èÆÔ∏è -1</button>
                    <button id="replay-step-btn" disabled>‚è≠Ô∏è +1</button>
                    <button id="replay-next-10-btn" disabled>‚è© +10</button>
                </div>
                
                <label>Replay Speed: <span class="value-display" id="replay-speed-value">1.0x</span></label>
                <input type="range" id="replay-speed-slider" min="0.1" max="5.0" step="0.1" value="1.0">
                
                <div class="replay-status">
                    <div>History: <span id="history-length">0</span> steps</div>
                    <div>Current: <span id="replay-current">0</span> / <span id="replay-total">0</span></div>
                </div>
            </div>
        </div>
        
        <!-- Initialization Options -->
        <div class="control-group">
            <div class="collapsible" id="init-controls-toggle">‚ñ∂ Initialization</div>
            <div class="collapsible-content" id="init-controls">
                <label>Initial State:</label>
                <select id="init-state-select">
                    <option value="clustered">Clustered</option>
                    <option value="scattered">Scattered</option>
                    <option value="random">Random</option>
                </select>
                
                <label>Seed: <span class="value-display" id="seed-value">None</span></label>
                <input type="number" id="seed-input" placeholder="Random seed">
                
                <button id="generate-state-btn">üé≤ Generate State</button>
            </div>
        </div>
    </div>
    
    <!-- Debug Information -->
    <div class="debug-info hidden" id="debug-info">
        <div id="debug-content">
            <div>FPS: <span id="debug-fps">0</span></div>
            <div>Boids: <span id="debug-boids">0</span></div>
            <div>Policy: <span id="debug-policy">None</span></div>
            <div>Frame: <span id="debug-frame">0</span></div>
            <div>Caught: <span id="debug-caught">0</span></div>
            <div>Canvas: <span id="debug-canvas-size">0√ó0</span></div>
        </div>
    </div>
    
    <!-- Performance Metrics -->
    <div class="performance-metrics hidden" id="performance-metrics">
        <div>FPS: <span id="perf-fps">0</span></div>
        <div>Frame Time: <span id="perf-frame-time">0</span>ms</div>
        <div>Total Frames: <span id="perf-total-frames">0</span></div>
    </div>
    
    <!-- Policy Status -->
    <div class="policy-status hidden" id="policy-status">
        <span class="status-indicator inactive" id="policy-indicator"></span>
        <span id="policy-name">No Policy</span>
    </div>
    
    <!-- Reward Information -->
    <div class="reward-info hidden" id="reward-info">
        <h3>Reward Analysis</h3>
        <div class="reward-details">
            <div class="reward-component">
                <span class="reward-label">Total:</span>
                <span id="reward-total" class="reward-value">0.000</span>
            </div>
            <div class="reward-component">
                <span class="reward-label">Approaching:</span>
                <span id="reward-approaching" class="reward-value">0.000</span>
            </div>
            <div class="reward-component">
                <span class="reward-label">Catch Retro:</span>
                <span id="reward-catch-retro" class="reward-value">0.000</span>
            </div>
        </div>
        <div class="reward-step-info">
            <div>Step: <span id="reward-step">0</span></div>
            <div>Boids: <span id="reward-boids-count">0</span></div>
            <div>Caught: <span id="reward-caught-this-step">0</span></div>
        </div>
    </div>

    <script>
        /**
         * Playground Simulation Class
         * Enhanced version of the simulation with debugging and testing features
         */
        function PlaygroundSimulation(canvasId) {
            this.canvas = document.getElementById(canvasId);
            this.ctx = this.canvas.getContext('2d');
            this.stateManager = new StateManager();
            this.policy = null;
            this.performanceMonitor = new PerformanceMonitor();
            this.rewardProcessor = new RewardProcessor();
            
            // Animation state
            this.isRunning = false;
            this.isPaused = false;
            this.animationId = null;
            this.speed = 1.0;
            this.stepMode = false;
            
            // Debug options
            this.showDebug = false;
            this.showVelocity = false;
            this.showRange = false;
            this.showIndices = false;
            this.showPerformance = false;
            this.showPolicyStatus = false;
            this.backgroundMode = 'transparent';
            
            // Statistics
            this.totalCaught = 0;
            this.frameCount = 0;
            
            // Replay system
            this.stepHistory = [];
            this.maxHistorySteps = 1000;
            this.isReplaying = false;
            this.replayIndex = 0;
            this.replaySpeed = 1.0;
            this.replayAnimationId = null;
            this.replayStepMode = false;
            this.preCalculatedRewards = []; // Store pre-calculated rewards
            
            // Initialize
            this.initializeControls();
            this.loadPolicy('transformer');
        }

        PlaygroundSimulation.prototype.initializeControls = function() {
            var self = this;
            
            // Simulation controls
            document.getElementById('start-btn').addEventListener('click', function() {
                self.start();
            });
            
            document.getElementById('pause-btn').addEventListener('click', function() {
                self.togglePause();
            });
            
            document.getElementById('reset-btn').addEventListener('click', function() {
                self.reset();
            });
            
            document.getElementById('step-btn').addEventListener('click', function() {
                self.step();
            });
            
            // Speed control
            document.getElementById('speed-slider').addEventListener('input', function(e) {
                self.speed = parseFloat(e.target.value);
                document.getElementById('speed-value').textContent = self.speed.toFixed(1) + 'x';
            });
            
            // Policy controls
            document.getElementById('policy-select').addEventListener('change', function(e) {
                self.loadPolicy(e.target.value);
            });
            
            document.getElementById('load-policy-btn').addEventListener('click', function() {
                var policyType = document.getElementById('policy-select').value;
                self.loadPolicy(policyType);
            });
            
            // Parameter controls
            self.setupParameterControls();
            
            // Visual controls
            document.getElementById('show-debug').addEventListener('change', function(e) {
                self.showDebug = e.target.checked;
                document.getElementById('debug-info').classList.toggle('hidden', !self.showDebug);
            });
            
            document.getElementById('show-velocity').addEventListener('change', function(e) {
                self.showVelocity = e.target.checked;
            });
            
            document.getElementById('show-range').addEventListener('change', function(e) {
                self.showRange = e.target.checked;
            });
            
            document.getElementById('show-indices').addEventListener('change', function(e) {
                self.showIndices = e.target.checked;
            });
            
            document.getElementById('show-performance').addEventListener('change', function(e) {
                self.showPerformance = e.target.checked;
                document.getElementById('performance-metrics').classList.toggle('hidden', !self.showPerformance);
            });
            
            document.getElementById('show-policy-status').addEventListener('change', function(e) {
                self.showPolicyStatus = e.target.checked;
                document.getElementById('policy-status').classList.toggle('hidden', !self.showPolicyStatus);
            });
            
            document.getElementById('background-select').addEventListener('change', function(e) {
                self.backgroundMode = e.target.value;
            });
            
            // Initialization controls
            document.getElementById('generate-state-btn').addEventListener('click', function() {
                self.generateInitialState();
            });
            
            // Replay controls
            document.getElementById('start-replay-btn').addEventListener('click', function() {
                self.startReplay();
            });
            
            document.getElementById('stop-replay-btn').addEventListener('click', function() {
                self.stopReplay();
            });
            
            document.getElementById('replay-step-btn').addEventListener('click', function() {
                self.replayStep();
            });
            
            document.getElementById('replay-prev-btn').addEventListener('click', function() {
                self.replayPreviousStep();
            });
            
            document.getElementById('replay-next-10-btn').addEventListener('click', function() {
                self.replayNext10Steps();
            });
            
            document.getElementById('replay-prev-10-btn').addEventListener('click', function() {
                self.replayPrevious10Steps();
            });
            
            document.getElementById('replay-speed-slider').addEventListener('input', function(e) {
                self.replaySpeed = parseFloat(e.target.value);
                document.getElementById('replay-speed-value').textContent = self.replaySpeed.toFixed(1) + 'x';
            });
            
            // Collapsible sections
            self.setupCollapsibles();
            
            // Window resize handling
            window.addEventListener('resize', function() {
                resizeCanvas('playground-canvas');
                if (self.stateManager.currentState) {
                    self.stateManager.currentState.canvas_width = self.canvas.width;
                    self.stateManager.currentState.canvas_height = self.canvas.height;
                }
            });
        };

        PlaygroundSimulation.prototype.setupParameterControls = function() {
            var self = this;
            
            // Boid parameter controls
            var boidParams = [
                { id: 'boid-count', prop: 'DEFAULT_NUM_BOIDS', needsReset: true },
                { id: 'boid-speed', prop: 'BOID_MAX_SPEED' },
                { id: 'boid-force', prop: 'BOID_MAX_FORCE' },
                { id: 'neighbor-dist', prop: 'BOID_NEIGHBOR_DISTANCE' },
                { id: 'separation', prop: 'SEPARATION_MULTIPLIER' },
                { id: 'cohesion', prop: 'COHESION_MULTIPLIER' },
                { id: 'alignment', prop: 'ALIGNMENT_MULTIPLIER' }
            ];
            
            boidParams.forEach(function(param) {
                var slider = document.getElementById(param.id + '-slider');
                var display = document.getElementById(param.id + '-value');
                
                slider.addEventListener('input', function(e) {
                    var value = parseFloat(e.target.value);
                    window.SIMULATION_CONSTANTS[param.prop] = value;
                    display.textContent = value.toString();
                    
                    if (param.needsReset && self.stateManager.currentState) {
                        self.generateInitialState();
                    }
                });
            });
            
            // Predator parameter controls
            var predatorParams = [
                { id: 'predator-speed', prop: 'PREDATOR_MAX_SPEED' },
                { id: 'predator-force', prop: 'PREDATOR_MAX_FORCE' },
                { id: 'predator-range', prop: 'PREDATOR_RANGE' },
                { id: 'turn-factor', prop: 'PREDATOR_TURN_FACTOR' }
            ];
            
            predatorParams.forEach(function(param) {
                var slider = document.getElementById(param.id + '-slider');
                var display = document.getElementById(param.id + '-value');
                
                slider.addEventListener('input', function(e) {
                    var value = parseFloat(e.target.value);
                    window.SIMULATION_CONSTANTS[param.prop] = value;
                    display.textContent = value.toString();
                });
            });
        };

        PlaygroundSimulation.prototype.setupCollapsibles = function() {
            var collapsibles = document.querySelectorAll('.collapsible');
            
            collapsibles.forEach(function(collapsible) {
                collapsible.addEventListener('click', function() {
                    var content = document.getElementById(this.id.replace('-toggle', ''));
                    var isActive = content.classList.contains('active');
                    
                    // Toggle active state
                    this.classList.toggle('active', !isActive);
                    content.classList.toggle('active', !isActive);
                    
                    // Update arrow
                    this.textContent = this.textContent.replace(/[‚ñº‚ñ∂]/, isActive ? '‚ñ∂' : '‚ñº');
                });
            });
        };

        PlaygroundSimulation.prototype.loadPolicy = function(policyType) {
            try {
                this.policy = createPolicy(policyType);
                this.updatePolicyStatus(policyType, 'active');
                console.log('Loaded policy:', policyType);
            } catch (error) {
                console.error('Failed to load policy:', policyType, error);
                this.updatePolicyStatus(policyType, 'inactive');
            }
        };

        PlaygroundSimulation.prototype.updatePolicyStatus = function(policyName, status) {
            var indicator = document.getElementById('policy-indicator');
            var nameElement = document.getElementById('policy-name');
            
            indicator.className = 'status-indicator ' + status;
            nameElement.textContent = policyName;
        };

        PlaygroundSimulation.prototype.generateInitialState = function() {
            resizeCanvas('playground-canvas');
            var canvasWidth = this.canvas.width;
            var canvasHeight = this.canvas.height;
            var numBoids = window.SIMULATION_CONSTANTS.DEFAULT_NUM_BOIDS;
            var initType = document.getElementById('init-state-select').value;
            var seedInput = document.getElementById('seed-input').value;
            var seed = seedInput ? parseInt(seedInput) : null;
            
            var initialState;
            if (initType === 'scattered') {
                initialState = generateScatteredState(numBoids, canvasWidth, canvasHeight);
            } else if (initType === 'random') {
                if (typeof generateRandomState === 'function') {
                    initialState = generateRandomState(numBoids, canvasWidth, canvasHeight, seed);
                } else {
                    initialState = generateClusteredState(numBoids, canvasWidth, canvasHeight);
                }
            } else {
                initialState = generateClusteredState(numBoids, canvasWidth, canvasHeight);
            }
            
            this.stateManager.init(initialState, this.policy);
            this.totalCaught = 0;
            this.frameCount = 0;
            
            // Clear step history and pre-calculated rewards when generating new state
            this.stepHistory = [];
            this.preCalculatedRewards = [];
            this.updateHistoryDisplay();
            
            console.log('Generated initial state:', initType, 'with', numBoids, 'boids');
        };

        PlaygroundSimulation.prototype.start = function() {
            if (!this.stateManager.currentState) {
                this.generateInitialState();
            }
            
            this.isRunning = true;
            this.isPaused = false;
            this.stepMode = false;
            this.animate();
            
            console.log('Simulation started');
        };

        PlaygroundSimulation.prototype.togglePause = function() {
            this.isPaused = !this.isPaused;
            if (!this.isPaused && this.isRunning) {
                this.animate();
            }
            
            console.log('Simulation', this.isPaused ? 'paused' : 'resumed');
        };

        PlaygroundSimulation.prototype.reset = function() {
            this.stop();
            this.generateInitialState();
            console.log('Simulation reset');
        };

        PlaygroundSimulation.prototype.step = function() {
            if (!this.stateManager.currentState) {
                this.generateInitialState();
            }
            
            this.stepMode = true;
            this.singleStep();
            this.render();
            this.updateDebugInfo();
            
            console.log('Single step executed');
        };

        PlaygroundSimulation.prototype.stop = function() {
            this.isRunning = false;
            this.isPaused = false;
            this.stepMode = false;
            
            if (this.animationId) {
                cancelAnimationFrame(this.animationId);
                this.animationId = null;
            }
            
            console.log('Simulation stopped');
        };

        PlaygroundSimulation.prototype.singleStep = function() {
            if (!this.stateManager.currentState || !this.policy) return;
            
            // Only run simulation during normal mode, not replay
            if (!this.isReplaying) {
                // Record step data BEFORE executing the step
                var preStepState = this.stateManager.getState();
                var structuredInputs = this.stateManager._convertStateToStructuredInputs(preStepState);
                var action = this.policy.getAction(structuredInputs);
                
                // Execute the simulation step
                var newState = this.stateManager.step();
                
                // Record this step with the caught boid IDs from StateManager
                var stepRecord = {
                    caughtBoids: newState.caught_boids || [],  // StateManager now returns boid IDs
                    state: structuredInputs,                   // State BEFORE step (for reward calculation)
                    action: action,                            // Action taken
                    visualState: {                             // Visual state BEFORE step (for replay)
                        boids_states: JSON.parse(JSON.stringify(preStepState.boids_states)),
                        predator_state: JSON.parse(JSON.stringify(preStepState.predator_state)),
                        canvas_width: preStepState.canvas_width,
                        canvas_height: preStepState.canvas_height
                    }
                };
                
                // Debug logging for catches
                if (stepRecord.caughtBoids.length > 0) {
                    console.log('üéØ CATCH RECORDED at step', this.stepHistory.length, ':', {
                        caughtBoidIds: stepRecord.caughtBoids,
                        totalBoidsInState: stepRecord.state.boids.length,
                        totalBoidsInVisual: stepRecord.visualState.boids_states.length
                    });
                }
                
                this.stepHistory.push(stepRecord);
                
                // Keep only last maxHistorySteps
                if (this.stepHistory.length > this.maxHistorySteps) {
                    this.stepHistory.shift();
                }
                
                this.updateHistoryDisplay();
                
                // Update total caught count
                if (newState.caught_boids && newState.caught_boids.length > 0) {
                    this.totalCaught += newState.caught_boids.length;
                }
                
                this.frameCount++;
            }
        };

        PlaygroundSimulation.prototype.animate = function() {
            if (!this.isRunning || this.isPaused || this.stepMode) return;
            
            // Apply speed control
            for (var i = 0; i < this.speed; i++) {
                this.singleStep();
            }
            
            this.render();
            this.updateDebugInfo();
            this.performanceMonitor.update();
            
            this.animationId = requestAnimationFrame(this.animate.bind(this));
        };

        PlaygroundSimulation.prototype.render = function() {
            if (!this.stateManager.currentState) return;
            
            // Clear canvas with background
            if (this.backgroundMode === 'transparent') {
                clearCanvas(this.ctx);
            } else if (this.backgroundMode === 'white') {
                clearCanvas(this.ctx, 'white');
            } else if (this.backgroundMode === 'black') {
                clearCanvas(this.ctx, 'black');
            } else if (this.backgroundMode === 'fade') {
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            }
            
            var currentState = this.stateManager.currentState;
            
            // Render boids
            for (var i = 0; i < currentState.boids_states.length; i++) {
                renderBoid(this.ctx, currentState.boids_states[i], window.SIMULATION_CONSTANTS.BOID_RENDER_SIZE);
                
                // Render debug info for boids
                if (this.showVelocity || this.showIndices) {
                    renderBoidDebug(this.ctx, currentState.boids_states[i], i, this.showVelocity, this.showIndices);
                }
            }
            
            // Render predator
            renderPredator(this.ctx, currentState.predator_state, window.SIMULATION_CONSTANTS.PREDATOR_SIZE);
            
            // Render predator debug info
            if (this.showVelocity || this.showRange) {
                renderPredatorDebug(this.ctx, currentState.predator_state, this.showVelocity, this.showRange);
            }
        };

        PlaygroundSimulation.prototype.updateDebugInfo = function() {
            if (!this.showDebug) return;
            
            var currentState = this.stateManager.currentState;
            var metrics = this.performanceMonitor.getMetrics();
            
            document.getElementById('debug-fps').textContent = metrics.fps;
            document.getElementById('debug-boids').textContent = currentState ? currentState.boids_states.length : 0;
            document.getElementById('debug-policy').textContent = this.policy ? this.policy.constructor.name : 'None';
            document.getElementById('debug-frame').textContent = this.frameCount;
            document.getElementById('debug-caught').textContent = this.totalCaught;
            document.getElementById('debug-canvas-size').textContent = this.canvas.width + '√ó' + this.canvas.height;
            
            // Update performance metrics
            if (this.showPerformance) {
                document.getElementById('perf-fps').textContent = metrics.fps;
                document.getElementById('perf-frame-time').textContent = metrics.frameTime;
                document.getElementById('perf-total-frames').textContent = metrics.frameCount;
            }
        };

        // === REPLAY SYSTEM METHODS ===

        PlaygroundSimulation.prototype.updateHistoryDisplay = function() {
            document.getElementById('history-length').textContent = this.stepHistory.length;
        };

        PlaygroundSimulation.prototype.startReplay = function() {
            if (this.stepHistory.length === 0) {
                console.warn('No step history available for replay');
                return;
            }
            
            // Stop normal simulation
            this.stop();
            
            // Pre-calculate rewards for entire episode ONCE
            console.log('Pre-calculating rewards for', this.stepHistory.length, 'steps...');
            
            // Determine if episode actually ended (all boids caught)
            var lastStep = this.stepHistory[this.stepHistory.length - 1];
            var isActualEpisodeEnd = lastStep.state.boids.length === 0;
            
            // Calculate rewards for the entire sequence
            this.preCalculatedRewards = this.rewardProcessor.processRewards(this.stepHistory, isActualEpisodeEnd);
            
            console.log('Pre-calculated', this.preCalculatedRewards.length, 'rewards, episode ended:', isActualEpisodeEnd);
            
            // Debug: Show first few rewards and any non-zero catch retro rewards
            if (this.preCalculatedRewards.length > 0) {
                console.log('First 3 rewards:', this.preCalculatedRewards.slice(0, 3));
                var catchRetroRewards = this.preCalculatedRewards.filter(r => r.catchRetro > 0);
                if (catchRetroRewards.length > 0) {
                    console.log('‚úÖ Non-zero catch retro rewards found:', catchRetroRewards.length, 'examples:', catchRetroRewards.slice(0, 3));
                } else {
                    console.log('‚ùå No catch retro rewards found - investigating...');
                    // Check if we recorded any catches
                    var stepsWithCatches = this.stepHistory.filter(s => s.caughtBoids.length > 0);
                    console.log('  Steps with catches recorded:', stepsWithCatches.length);
                    if (stepsWithCatches.length > 0) {
                        console.log('  Example catch step:', stepsWithCatches[0]);
                        console.log('  All catch steps:', stepsWithCatches.map(s => ({
                            step: this.stepHistory.indexOf(s),
                            caughtIds: s.caughtBoids,
                            boidCount: s.state.boids.length
                        })));
                    }
                }
            }
            
            // Enter replay mode
            this.isReplaying = true;
            this.replayIndex = 0;
            this.replayStepMode = false;
            
            // Update UI
            document.getElementById('start-replay-btn').disabled = true;
            document.getElementById('stop-replay-btn').disabled = false;
            document.getElementById('replay-step-btn').disabled = false;
            document.getElementById('replay-prev-btn').disabled = false;
            document.getElementById('replay-next-10-btn').disabled = false;
            document.getElementById('replay-prev-10-btn').disabled = false;
            document.getElementById('reward-info').classList.remove('hidden');
            
            // Update replay status
            this.updateReplayStatus();
            
            // Set initial replay state
            if (this.stepHistory.length > 0 && this.stepHistory[0].visualState) {
                this.stateManager.currentState = JSON.parse(JSON.stringify(this.stepHistory[0].visualState));
                this.render(); // Show initial state
                
                // Show initial reward
                this.updateRewardDisplay(this.getRewardForStep(0), 0);
            }
            
            // Start replay animation
            this.replayAnimate();
            
            console.log('Started replay with', this.stepHistory.length, 'steps');
        };

        PlaygroundSimulation.prototype.stopReplay = function() {
            // Exit replay mode
            this.isReplaying = false;
            this.replayStepMode = false;
            
            if (this.replayAnimationId) {
                cancelAnimationFrame(this.replayAnimationId);
                this.replayAnimationId = null;
            }
            
            // Update UI
            document.getElementById('start-replay-btn').disabled = false;
            document.getElementById('stop-replay-btn').disabled = true;
            document.getElementById('replay-step-btn').disabled = true;
            document.getElementById('replay-prev-btn').disabled = true;
            document.getElementById('replay-next-10-btn').disabled = true;
            document.getElementById('replay-prev-10-btn').disabled = true;
            document.getElementById('reward-info').classList.add('hidden');
            
            console.log('Stopped replay');
        };

        PlaygroundSimulation.prototype.replayStep = function() {
            if (!this.isReplaying) return;
            
            // Go forward one step (but not beyond end)
            if (this.replayIndex < this.stepHistory.length - 1) {
                this.replayIndex++;
            }
            
            this.replayStepMode = true;
            this.updateReplayStateAndDisplay();
        };

        PlaygroundSimulation.prototype.singleReplayStep = function() {
            if (this.replayIndex >= this.stepHistory.length) {
                this.stopReplay();
                return;
            }
            
            // Use shared update logic
            this.updateReplayStateAndDisplay();
            
            // Advance to next step for automatic playback
            this.replayIndex++;
        };

        PlaygroundSimulation.prototype.getRewardForStep = function(stepIndex) {
            // Return pre-calculated reward or zero if not available
            if (stepIndex >= 0 && stepIndex < this.preCalculatedRewards.length) {
                return this.preCalculatedRewards[stepIndex];
            }
            return { total: 0, approaching: 0, catchRetro: 0 };
        };

        // === NEW NAVIGATION METHODS ===

        PlaygroundSimulation.prototype.replayPreviousStep = function() {
            if (!this.isReplaying) return;
            
            // Go back one step (but not below 0)
            this.replayIndex = Math.max(0, this.replayIndex - 1);
            
            this.replayStepMode = true;
            this.updateReplayStateAndDisplay();
        };

        PlaygroundSimulation.prototype.replayNext10Steps = function() {
            if (!this.isReplaying) return;
            
            // Go forward 10 steps (but not beyond end)
            var targetIndex = Math.min(this.stepHistory.length - 1, this.replayIndex + 10);
            this.replayIndex = targetIndex;
            
            this.replayStepMode = true;
            this.updateReplayStateAndDisplay();
        };

        PlaygroundSimulation.prototype.replayPrevious10Steps = function() {
            if (!this.isReplaying) return;
            
            // Go back 10 steps (but not below 0)
            this.replayIndex = Math.max(0, this.replayIndex - 10);
            
            this.replayStepMode = true;
            this.updateReplayStateAndDisplay();
        };

        PlaygroundSimulation.prototype.updateReplayStateAndDisplay = function() {
            if (this.replayIndex < this.stepHistory.length) {
                // Get current step data
                var currentStep = this.stepHistory[this.replayIndex];
                
                // Restore visual state for this step
                if (currentStep.visualState) {
                    this.stateManager.currentState = JSON.parse(JSON.stringify(currentStep.visualState));
                }
                
                // Get pre-calculated reward for this step
                var currentReward = this.getRewardForStep(this.replayIndex);
                
                // Update displays
                this.render();
                this.updateRewardDisplay(currentReward, this.replayIndex);
                this.updateReplayStatus();
            }
        };

        PlaygroundSimulation.prototype.replayAnimate = function() {
            if (!this.isReplaying || this.replayStepMode) return;
            
            // Apply speed control
            for (var i = 0; i < this.replaySpeed; i++) {
                this.singleReplayStep();
            }
            
            this.updateReplayDisplay();
            
            if (this.replayIndex < this.stepHistory.length) {
                this.replayAnimationId = requestAnimationFrame(this.replayAnimate.bind(this));
            } else {
                this.stopReplay();
            }
        };

        PlaygroundSimulation.prototype.updateReplayStatus = function() {
            document.getElementById('replay-current').textContent = this.replayIndex;
            document.getElementById('replay-total').textContent = this.stepHistory.length;
        };

        PlaygroundSimulation.prototype.updateReplayDisplay = function() {
            this.updateReplayStatus();
            // Render the current replay state
            this.render();
        };

        PlaygroundSimulation.prototype.updateRewardDisplay = function(reward, stepIndex) {
            document.getElementById('reward-total').textContent = reward.total.toFixed(3);
            document.getElementById('reward-approaching').textContent = reward.approaching.toFixed(3);
            document.getElementById('reward-catch-retro').textContent = reward.catchRetro.toFixed(3);
            
            var stepData = this.stepHistory[stepIndex];
            if (stepData) {
                document.getElementById('reward-step').textContent = stepIndex;
                document.getElementById('reward-boids-count').textContent = stepData.state.boids.length;
                document.getElementById('reward-caught-this-step').textContent = stepData.caughtBoids.length;
            }
        };

        /**
         * Initialize playground on page load
         */
        document.addEventListener('DOMContentLoaded', function() {
            if (!isCanvasSupported()) {
                console.error("Canvas not supported");
                return;
            }
            
            // Create playground simulation
            var playground = new PlaygroundSimulation('playground-canvas');
            
            // Store globally for debugging
            window.playground = playground;
            
            console.log('Playground initialized');
        });
    </script>
</body>
</html> 